<!DOCTYPE html>
<html lang="en"><head><meta charset="UTF-8"/><meta name="viewport" content="width=device-width, initial-scale=1.0"/><title>Home · MLJScientificTypes.jl</title><link href="https://fonts.googleapis.com/css?family=Lato|Roboto+Mono" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/5.11.2/css/fontawesome.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/5.11.2/css/solid.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/5.11.2/css/brands.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/KaTeX/0.11.1/katex.min.css" rel="stylesheet" type="text/css"/><script>documenterBaseURL="."</script><script src="https://cdnjs.cloudflare.com/ajax/libs/require.js/2.3.6/require.min.js" data-main="assets/documenter.js"></script><script src="siteinfo.js"></script><script src="../versions.js"></script><link class="docs-theme-link" rel="stylesheet" type="text/css" href="assets/themes/documenter-dark.css" data-theme-name="documenter-dark"/><link class="docs-theme-link" rel="stylesheet" type="text/css" href="assets/themes/documenter-light.css" data-theme-name="documenter-light" data-theme-primary/><script src="assets/themeswap.js"></script></head><body><div id="documenter"><nav class="docs-sidebar"><div class="docs-package-name"><span class="docs-autofit">MLJScientificTypes.jl</span></div><form class="docs-search" action="search/"><input class="docs-search-query" id="documenter-search-query" name="q" type="text" placeholder="Search docs"/></form><ul class="docs-menu"><li class="is-active"><a class="tocitem" href>Home</a><ul class="internal"><li><a class="tocitem" href="#Type-hierarchy-1"><span>Type hierarchy</span></a></li><li><a class="tocitem" href="#Getting-started-1"><span>Getting started</span></a></li><li><a class="tocitem" href="#Type-coercion-for-tabular-data-1"><span>Type coercion for tabular data</span></a></li><li><a class="tocitem" href="#Notes-1"><span>Notes</span></a></li><li><a class="tocitem" href="#Detailed-usage-examples-1"><span>Detailed usage examples</span></a></li><li><a class="tocitem" href="#Working-with-tables-1"><span>Working with tables</span></a></li><li><a class="tocitem" href="#Tuples,-arrays-and-tables-1"><span>Tuples, arrays and tables</span></a></li><li><a class="tocitem" href="#The-MLJ-convention-1"><span>The MLJ convention</span></a></li><li><a class="tocitem" href="#Automatic-type-conversion-1"><span>Automatic type conversion</span></a></li></ul></li></ul><div class="docs-version-selector field has-addons"><div class="control"><span class="docs-label button is-static is-size-7">Version</span></div><div class="docs-selector control is-expanded"><div class="select is-fullwidth is-size-7"><select id="documenter-version-selector"></select></div></div></div></nav><div class="docs-main"><header class="docs-navbar"><nav class="breadcrumb"><ul class="is-hidden-mobile"><li class="is-active"><a href>Home</a></li></ul><ul class="is-hidden-tablet"><li class="is-active"><a href>Home</a></li></ul></nav><div class="docs-right"><a class="docs-edit-link" href="https://github.com/alan-turing-institute/MLJScientificTypes.jl/blob/master/docs/src/index.md" title="Edit on GitHub"><span class="docs-icon fab"></span><span class="docs-label is-hidden-touch">Edit on GitHub</span></a><a class="docs-settings-button fas fa-cog" id="documenter-settings-button" href="#" title="Settings"></a><a class="docs-sidebar-button fa fa-bars is-hidden-desktop" id="documenter-sidebar-button" href="#"></a></div></header><article class="content" id="documenter-page"><h1 id="MLJScientificTypes.jl-1"><a class="docs-heading-anchor" href="#MLJScientificTypes.jl-1">MLJScientificTypes.jl</a><a class="docs-heading-anchor-permalink" href="#MLJScientificTypes.jl-1" title="Permalink"></a></h1><p>Implementation of the MLJ convention for <a href="https://github.com/alan-turing-institute/ScientificTypes.jl">Scientific Types</a>. Scientific Types allow the distinction between <strong>machine type</strong> and <strong>scientific type</strong>:</p><ul><li>the <em>machine type</em> is a Julia type the data is currently encoded as (for</li></ul><p>instance: <code>Float64</code>)</p><ul><li>the <em>scientific type</em> is a type defined by this package which encapsulates how the data should be <em>interpreted</em> (for instance: <code>Continuous</code> or <code>Multiclass</code>)</li></ul><p>Determining what scientific type should be given to what data is determined by a convention such as the one this package implements which is the one in use in the <a href="https://github.com/alan-turing-institute/MLJ.jl">MLJ</a> universe.</p><h2 id="Type-hierarchy-1"><a class="docs-heading-anchor" href="#Type-hierarchy-1">Type hierarchy</a><a class="docs-heading-anchor-permalink" href="#Type-hierarchy-1" title="Permalink"></a></h2><p>The supported scientific types have the following hierarchy:</p><pre><code class="language-none">Found
├─ Known
│  ├─ Finite
│  │  ├─ Multiclass
│  │  └─ OrderedFactor
│  ├─ Infinite
│  │  ├─ Continuous
│  │  └─ Count
│  ├─ Image
│  │  ├─ ColorImage
│  │  └─ GrayImage
|  ├─ Textual
│  └─ Table
└─ Unknown</code></pre><h2 id="Getting-started-1"><a class="docs-heading-anchor" href="#Getting-started-1">Getting started</a><a class="docs-heading-anchor-permalink" href="#Getting-started-1" title="Permalink"></a></h2><p>The package is registered and can be installed via the package manager with <code>add MLJScientificTypes</code>.</p><p>To get the scientific type of a Julia object according to the MLJ convention, call <code>scitype</code>:</p><pre><code class="language-julia">scitype(3.14)</code></pre><pre><code class="language-none">Continuous</code></pre><p>For a vector, you can use <code>scitype</code> or <code>elscitype</code> (which will give you a scitype corresponding to the elements):</p><pre><code class="language-julia">scitype([1,2,3,missing])</code></pre><pre><code class="language-none">AbstractArray{Union{Missing, Count},1}</code></pre><pre><code class="language-julia">elscitype([1,2,3,missing])</code></pre><pre><code class="language-none">Union{Missing, Count}</code></pre><p>For an iterable, you can use <code>scitype_union</code> which gives you the tightest union of scitypes corresponding to the elements:</p><pre><code class="language-julia">scitype_union((ifelse(isodd(i), i, missing) for i in 1:5))</code></pre><pre><code class="language-none">Union{Missing, Count}</code></pre><p>note that <code>scitype_union</code> has to go over all elements which is slow whereas <code>scitype</code> and <code>elscitype</code> can often be immediately returned upon inspection of   the machine type.</p><h2 id="Type-coercion-for-tabular-data-1"><a class="docs-heading-anchor" href="#Type-coercion-for-tabular-data-1">Type coercion for tabular data</a><a class="docs-heading-anchor-permalink" href="#Type-coercion-for-tabular-data-1" title="Permalink"></a></h2><p>The standard workflow involves the following two steps:</p><ol><li>inspect the <code>schema</code> of the data and the <code>scitypes</code> in particular</li><li>provide pairs or a dictionary with column names and scitypes for any changes</li></ol><p>you may want and coerce the data to those scitypes</p><pre><code class="language-julia">using DataFrames, Tables
X = DataFrame(
     name=[&quot;Siri&quot;, &quot;Robo&quot;, &quot;Alexa&quot;, &quot;Cortana&quot;],
     height=[152, missing, 148, 163],
     rating=[1, 5, 2, 1])
schema(X)</code></pre><pre><code class="language-none">_.table = 
┌─────────┬───────────────────────┬───────────────────────┐
│ _.names │ _.types               │ _.scitypes            │
├─────────┼───────────────────────┼───────────────────────┤
│ name    │ String                │ Textual               │
│ height  │ Union{Missing, Int64} │ Union{Missing, Count} │
│ rating  │ Int64                 │ Count                 │
└─────────┴───────────────────────┴───────────────────────┘
_.nrows = 4
</code></pre><p>inspecting the scitypes:</p><pre><code class="language-julia">schema(X).scitypes</code></pre><pre><code class="language-none">(Textual, Union{Missing, Count}, Count)</code></pre><p>but in this case you may want to map the names to <code>Multiclass</code>, the height to <code>Continuous</code> and the ratings to <code>OrderedFactor</code>; to do so use the <code>coerce</code> function:</p><pre><code class="language-julia">Xfixed = coerce(X, :name=&gt;Multiclass,
                   :height=&gt;Continuous,
                   :rating=&gt;OrderedFactor)
schema(Xfixed).scitypes</code></pre><pre><code class="language-none">(Multiclass{4}, Union{Missing, Continuous}, OrderedFactor{3})</code></pre><p>Note that, as it encountered missing values in <code>height</code> it coerced the type to <code>Union{Missing,Continuous}</code> and a warning is issued (to avoid such warnings, coerce to <code>Union{Missing,T}</code> where appropriate)</p><p>One can also make a replacement based on existing scientific type, instead of feature name:</p><pre><code class="language-julia">X  = (x = [1, 2, 3],
      y = rand(3),
      z = [10, 20, 30])
Xfixed = coerce(X, Count=&gt;Continuous)
schema(Xfixed).scitypes</code></pre><pre><code class="language-none">(Continuous, Continuous, Continuous)</code></pre><p>Finally there is a <code>coerce!</code> method that does in-place coercion provided the data structure allows it (at the moment only <code>DataFrames.DataFrame</code> is supported).</p><h2 id="Notes-1"><a class="docs-heading-anchor" href="#Notes-1">Notes</a><a class="docs-heading-anchor-permalink" href="#Notes-1" title="Permalink"></a></h2><ul><li>We regard the built-in Julia type <code>Missing</code> as a scientific type. The new scientific types introduced in the current package are rooted in the abstract type <code>Found</code> (see tree above).</li><li><code>Finite{N}</code>, <code>Multiclass{N}</code> and <code>OrderedFactor{N}</code> are all parametrised by the number of levels <code>N</code>. We export the alias <code>Binary = Finite{2}</code>.</li><li><code>Image{W,H}</code>, <code>GrayImage{W,H}</code> and <code>ColorImage{W,H}</code> are all parametrised by the image width and height dimensions, <code>(W, H)</code>.</li><li>The function <code>scitype</code> has the fallback value <code>Unknown</code>.</li></ul><h3 id="Special-note-on-binary-data-1"><a class="docs-heading-anchor" href="#Special-note-on-binary-data-1">Special note on binary data</a><a class="docs-heading-anchor-permalink" href="#Special-note-on-binary-data-1" title="Permalink"></a></h3><p>MLJScientificTypes does not define a separate &quot;binary&quot; scientific type. Rather, when binary data has an intrinsic &quot;true&quot; class (for example pass/fail in a product test), then it should be assigned an <code>OrderedFactor{2}</code> scitype, while data with no such class (e.g., gender) should be assigned a <code>Multiclass{2}</code> scitype. In the former case we recommend that the &quot;true&quot; class come after &quot;false&quot; in the ordering (corresponding to the usual assignment &quot;false=0&quot; and &quot;true=1&quot;). Of course, <code>Finite{2}</code> covers both cases of binary data.</p><h2 id="Detailed-usage-examples-1"><a class="docs-heading-anchor" href="#Detailed-usage-examples-1">Detailed usage examples</a><a class="docs-heading-anchor-permalink" href="#Detailed-usage-examples-1" title="Permalink"></a></h2><pre><code class="language-julia">using CategoricalArrays
scitype((2.718, 42))</code></pre><pre><code class="language-none">Tuple{Continuous,Count}</code></pre><p>Let&#39;s try with categorical valued objects:</p><pre><code class="language-julia">v = categorical([&#39;a&#39;, &#39;c&#39;, &#39;a&#39;, missing, &#39;b&#39;], ordered=true)
scitype(v[1])</code></pre><pre><code class="language-none">OrderedFactor{3}</code></pre><p>and</p><pre><code class="language-julia">elscitype(v)</code></pre><pre><code class="language-none">Union{Missing, OrderedFactor{3}}</code></pre><p>you could coerce this to <code>Multiclass</code>:</p><pre><code class="language-julia">w = coerce(v, Union{Missing,Multiclass})
elscitype(w)</code></pre><pre><code class="language-none">Union{Missing, Multiclass{3}}</code></pre><h2 id="Working-with-tables-1"><a class="docs-heading-anchor" href="#Working-with-tables-1">Working with tables</a><a class="docs-heading-anchor-permalink" href="#Working-with-tables-1" title="Permalink"></a></h2><pre><code class="language-julia">data = (x1=rand(10), x2=rand(10))
scitype(data)</code></pre><pre><code class="language-none">Table{AbstractArray{Continuous,1}}</code></pre><p>you can also use <code>schema</code>:</p><pre><code class="language-julia">schema(data)</code></pre><pre><code class="language-none">_.table = 
┌─────────┬─────────┬────────────┐
│ _.names │ _.types │ _.scitypes │
├─────────┼─────────┼────────────┤
│ x1      │ Float64 │ Continuous │
│ x2      │ Float64 │ Continuous │
└─────────┴─────────┴────────────┘
_.nrows = 10
</code></pre><p>and use <code>&lt;:</code> for type checks:</p><pre><code class="language-julia">scitype(data) &lt;: Table(Continuous)</code></pre><pre><code class="language-none">true</code></pre><pre><code class="language-julia">scitype(data) &lt;: Table(Infinite)</code></pre><pre><code class="language-none">true</code></pre><p>or specify multiple types directly:</p><pre><code class="language-julia">data = (x=rand(10), y=collect(1:10), z = [1,2,3,1,2,3,1,2,3,1])
data = coerce(data, :z=&gt;OrderedFactor)
scitype(data) &lt;: Table(Continuous,Count,OrderedFactor)</code></pre><pre><code class="language-none">true</code></pre><h2 id="Tuples,-arrays-and-tables-1"><a class="docs-heading-anchor" href="#Tuples,-arrays-and-tables-1">Tuples, arrays and tables</a><a class="docs-heading-anchor-permalink" href="#Tuples,-arrays-and-tables-1" title="Permalink"></a></h2><p><strong>Important Definition 1</strong> Under any convention, the scitype of a tuple is a <code>Tuple</code> type parametrised by scientific types:</p><pre><code class="language-julia">scitype((1, 4.5))</code></pre><pre><code class="language-none">Tuple{Count,Continuous}</code></pre><p><strong>Important Definition 2</strong> The scitype of an <code>AbstractArray</code>, <code>A</code>, is always<code>AbstractArray{U}</code> where <code>U</code> is the union of the scitypes of the elements of <code>A</code>, with one exception: If <code>typeof(A) &lt;: AbstractArray{Union{Missing,T}}</code> for some <code>T</code> different from <code>Any</code>, then the scitype of <code>A</code> is <code>AbstractArray{Union{Missing, U}}</code>, where <code>U</code> is the union over all non-missing elements, <strong>even if <code>A</code> has no missing elements</strong>.</p><p>This exception is made for performance reasons. If one wants to override it, one uses <code>scitype(A, tight=true)</code>.</p><pre><code class="language-julia">v = [1.3, 4.5, missing]
scitype(v)</code></pre><pre><code class="language-none">AbstractArray{Union{Missing, Continuous},1}</code></pre><pre><code class="language-julia">scitype(v[1:2])</code></pre><pre><code class="language-none">AbstractArray{Union{Missing, Continuous},1}</code></pre><pre><code class="language-julia">scitype(v[1:2], tight=true)</code></pre><pre><code class="language-none">AbstractArray{Continuous,1}</code></pre><p><em>Performance note:</em> Computing type unions over large arrays is expensive and, depending on the convention&#39;s implementation and the array eltype, computing the scitype can be slow. In the <em>MLJ</em> convention this is mitigated with the help of the <code>ScientificTypes.Scitype</code> method, of which other conventions could make use. Do <code>?ScientificTypes.Scitype</code> for details. An eltype <code>Any</code> may lead to poor performances and you may want to consider replacing an array <code>A</code> with <code>broadcast(identity, A)</code> to collapse the eltype and speed up the computation.</p><p>Any table implementing the Tables interface has a scitype encoding the scitypes of its columns:</p><pre><code class="language-julia">using CategoricalArrays
X = (x1=rand(10),
     x2=rand(10),
     x3=categorical(rand(&quot;abc&quot;, 10)),
     x4=categorical(rand(&quot;01&quot;, 10)))
schema(X)</code></pre><pre><code class="language-none">_.table = 
┌─────────┬─────────────────────────────────────────────────┬───────────────┐
│ _.names │ _.types                                         │ _.scitypes    │
├─────────┼─────────────────────────────────────────────────┼───────────────┤
│ x1      │ Float64                                         │ Continuous    │
│ x2      │ Float64                                         │ Continuous    │
│ x3      │ CategoricalArrays.CategoricalValue{Char,UInt32} │ Multiclass{3} │
│ x4      │ CategoricalArrays.CategoricalValue{Char,UInt32} │ Multiclass{2} │
└─────────┴─────────────────────────────────────────────────┴───────────────┘
_.nrows = 10
</code></pre><p><strong>Important Definition 3</strong> Specifically, if <code>X</code> has columns <code>c1, ..., cn</code>, then</p><pre><code class="language-julia">scitype(X) == Table{Union{scitype(c1), ..., scitype(cn)}}</code></pre><p>With this definition, common type checks can be performed with tables. For instance, you could check that each column of <code>X</code> has an element scitype that is either <code>Continuous</code> or <code>Finite</code>:</p><pre><code class="language-julia">scitype(X) &lt;: Table{&lt;:Union{AbstractVector{&lt;:Continuous}, AbstractVector{&lt;:Finite}}}</code></pre><pre><code class="language-none">true</code></pre><p>A built-in <code>Table</code> constructor provides a shorthand for the right-hand side:</p><pre><code class="language-julia">scitype(X) &lt;: Table(Continuous, Finite)</code></pre><pre><code class="language-none">true</code></pre><p>Note that <code>Table(Continuous,Finite)</code> is a <em>type</em> union and not a <code>Table</code> <em>instance</em>.</p><h2 id="The-MLJ-convention-1"><a class="docs-heading-anchor" href="#The-MLJ-convention-1">The MLJ convention</a><a class="docs-heading-anchor-permalink" href="#The-MLJ-convention-1" title="Permalink"></a></h2><p>The table below summarises the <em>MLJ</em> convention for representing scientific types:</p><table><tr><th style="text-align: left">Type <code>T</code></th><th style="text-align: left"><code>scitype(x)</code> for <code>x::T</code></th><th style="text-align: left">package required</th></tr><tr><td style="text-align: left"><code>Missing</code></td><td style="text-align: left"><code>Missing</code></td><td style="text-align: left"></td></tr><tr><td style="text-align: left"><code>AbstractFloat</code></td><td style="text-align: left"><code>Continuous</code></td><td style="text-align: left"></td></tr><tr><td style="text-align: left"><code>Integer</code></td><td style="text-align: left"><code>Count</code></td><td style="text-align: left"></td></tr><tr><td style="text-align: left"><code>String</code></td><td style="text-align: left"><code>Textual</code></td><td style="text-align: left"></td></tr><tr><td style="text-align: left"><code>CategoricalValue</code></td><td style="text-align: left"><code>Multiclass{N}</code> where <code>N = nlevels(x)</code>, provided <code>x.pool.ordered == false</code></td><td style="text-align: left">CategoricalArrays</td></tr><tr><td style="text-align: left"><code>CategoricalString</code></td><td style="text-align: left"><code>Multiclass{N}</code> where <code>N = nlevels(x)</code>, provided <code>x.pool.ordered == false</code></td><td style="text-align: left">CategoricalArrays</td></tr><tr><td style="text-align: left"><code>CategoricalValue</code></td><td style="text-align: left"><code>OrderedFactor{N}</code> where <code>N = nlevels(x)</code>, provided <code>x.pool.ordered == true</code></td><td style="text-align: left">CategoricalArrays</td></tr><tr><td style="text-align: left"><code>CategoricalString</code></td><td style="text-align: left"><code>OrderedFactor{N}</code> where <code>N = nlevels(x)</code> provided <code>x.pool.ordered == true</code></td><td style="text-align: left">CategoricalArrays</td></tr><tr><td style="text-align: left"><code>AbstractArray{&lt;:Gray,2}</code></td><td style="text-align: left"><code>GrayImage{W,H}</code> where <code>(W, H) = size(x)</code></td><td style="text-align: left">ColorTypes</td></tr><tr><td style="text-align: left"><code>AbstractArrray{&lt;:AbstractRGB,2}</code></td><td style="text-align: left"><code>ColorImage{W,H}</code> where <code>(W, H) = size(x)</code></td><td style="text-align: left">ColorTypes</td></tr><tr><td style="text-align: left">any table type <code>T</code> supported by Tables.jl</td><td style="text-align: left"><code>Table{K}</code> where <code>K=Union{column_scitypes...}</code></td><td style="text-align: left">Tables</td></tr></table><p>Here <code>nlevels(x) = length(levels(x.pool))</code>.</p><h2 id="Automatic-type-conversion-1"><a class="docs-heading-anchor" href="#Automatic-type-conversion-1">Automatic type conversion</a><a class="docs-heading-anchor-permalink" href="#Automatic-type-conversion-1" title="Permalink"></a></h2><p>The <code>autotype</code> function allows to use specific rules in order to guess appropriate scientific types for <em>tabular</em> data. Such rules would typically be more constraining than the ones implied by the active convention. When <code>autotype</code> is used, a dictionary of suggested types is returned for each column in the data; if none of the specified rule applies, the ambient convention is used as &quot;fallback&quot;.</p><p>The function is called as:</p><pre><code class="language-julia">autotype(X)</code></pre><p>If the keyword <code>only_changes</code> is passed set to <code>true</code>, then only the column names for which the suggested type is different from that provided by the convention are returned.</p><pre><code class="language-julia">autotype(X; only_changes=true)</code></pre><p>To specify which rules are to be applied, use the <code>rules</code> keyword  and specify a tuple of symbols referring to specific rules; the default rule is <code>:few_to_finite</code> which applies a heuristic for columns which have relatively few values, these columns are then encoded with an appropriate <code>Finite</code> type. It is important to note that the order in which the rules are specified matters; rules will be applied in that order.</p><pre><code class="language-julia">autotype(X; rules=(:few_to_finite,))</code></pre><p>Finally, you can also use the following shorthands:</p><pre><code class="language-julia">autotype(X, :few_to_finite)
autotype(X, (:few_to_finite, :discrete_to_continuous))</code></pre><h3 id="Available-rules-1"><a class="docs-heading-anchor" href="#Available-rules-1">Available rules</a><a class="docs-heading-anchor-permalink" href="#Available-rules-1" title="Permalink"></a></h3><table><tr><th style="text-align: left">Rule symbol</th><th style="text-align: left">scitype suggestion</th></tr><tr><td style="text-align: left"><code>:few_to_finite</code></td><td style="text-align: left">an appropriate <code>Finite</code> subtype for columns with few distinct values</td></tr><tr><td style="text-align: left"><code>:discrete_to_continuous</code></td><td style="text-align: left">if not <code>Finite</code>, then <code>Continuous</code> for any <code>Count</code> or <code>Integer</code> scitypes/types</td></tr><tr><td style="text-align: left"><code>:string_to_multiclass</code></td><td style="text-align: left"><code>Multiclass</code> for any string-like column</td></tr></table><p>Autotype can be used in conjunction with <code>coerce</code>:</p><pre><code class="language-none">X_coerced = coerce(X, autotype(X))</code></pre><h3 id="Examples-1"><a class="docs-heading-anchor" href="#Examples-1">Examples</a><a class="docs-heading-anchor-permalink" href="#Examples-1" title="Permalink"></a></h3><p>By default it only applies the <code>:few_to_many</code> rule</p><pre><code class="language-julia">n = 50
X = (a = rand(&quot;abc&quot;, n),         # 3 values, not number        --&gt; Multiclass
     b = rand([1,2,3,4], n),     # 4 values, number            --&gt; OrderedFactor
     c = rand([true,false], n),  # 2 values, number but only 2 --&gt; Multiclass
     d = randn(n),               # many values                 --&gt; unchanged
     e = rand(collect(1:n), n))  # many values                 --&gt; unchanged
autotype(X, only_changes=true)</code></pre><pre><code class="language-none">Dict{Symbol,Type{#s19} where #s19&lt;:Union{Missing, Found}} with 3 entries:
  :a =&gt; Multiclass
  :b =&gt; OrderedFactor
  :c =&gt; OrderedFactor</code></pre><p>For example, we could first apply the <code>:discrete_to_continuous</code> rule, followed by <code>:few_to_finite</code> rule. The first rule will apply to <code>b</code> and <code>e</code> but the subsequent application of the second rule will mean we will get the same result apart for <code>e</code> (which will be <code>Continuous</code>)</p><pre><code class="language-julia">autotype(X, only_changes=true, rules=(:discrete_to_continuous, :few_to_finite))</code></pre><pre><code class="language-none">Dict{Symbol,Type{#s19} where #s19&lt;:Union{Missing, Found}} with 4 entries:
  :a =&gt; Multiclass
  :b =&gt; OrderedFactor
  :e =&gt; Continuous
  :c =&gt; OrderedFactor</code></pre><p>One should check and possibly modify the returned dictionary before passing to <code>coerce</code>.</p></article></div><div class="modal" id="documenter-settings"><div class="modal-background"></div><div class="modal-card"><header class="modal-card-head"><p class="modal-card-title">Settings</p><button class="delete"></button></header><section class="modal-card-body"><p><label class="label">Theme</label><div class="select"><select id="documenter-themepicker"><option value="documenter-light">documenter-light</option><option value="documenter-dark">documenter-dark</option></select></div></p><hr/><p>This document was generated with <a href="https://github.com/JuliaDocs/Documenter.jl">Documenter.jl</a> on <span class="colophon-date" title="Sunday 2 February 2020 14:32">Sunday 2 February 2020</span>. Using Julia version 1.3.1.</p></section><footer class="modal-card-foot"></footer></div></div></div></body></html>
