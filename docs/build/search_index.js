var documenterSearchIndex = {"docs":
[{"location":"#MLJScientificTypes.jl-1","page":"Home","title":"MLJScientificTypes.jl","text":"","category":"section"},{"location":"#","page":"Home","title":"Home","text":"Implementation of the MLJ convention for Scientific Types. Scientific Types allow the distinction between machine type and scientific type:","category":"page"},{"location":"#","page":"Home","title":"Home","text":"the machine type is a Julia type the data is currently encoded as (for","category":"page"},{"location":"#","page":"Home","title":"Home","text":"instance: Float64)","category":"page"},{"location":"#","page":"Home","title":"Home","text":"the scientific type is a type defined by this package which encapsulates how the data should be interpreted (for instance: Continuous or Multiclass)","category":"page"},{"location":"#","page":"Home","title":"Home","text":"Determining what scientific type should be given to what data is determined by a convention such as the one this package implements which is the one in use in the MLJ universe.","category":"page"},{"location":"#Type-hierarchy-1","page":"Home","title":"Type hierarchy","text":"","category":"section"},{"location":"#","page":"Home","title":"Home","text":"The supported scientific types have the following hierarchy:","category":"page"},{"location":"#","page":"Home","title":"Home","text":"Found\n├─ Known\n│  ├─ Finite\n│  │  ├─ Multiclass\n│  │  └─ OrderedFactor\n│  ├─ Infinite\n│  │  ├─ Continuous\n│  │  └─ Count\n│  ├─ Image\n│  │  ├─ ColorImage\n│  │  └─ GrayImage\n|  ├─ Textual\n│  └─ Table\n└─ Unknown","category":"page"},{"location":"#Getting-started-1","page":"Home","title":"Getting started","text":"","category":"section"},{"location":"#","page":"Home","title":"Home","text":"The package is registered and can be installed via the package manager with add MLJScientificTypes.","category":"page"},{"location":"#","page":"Home","title":"Home","text":"To get the scientific type of a Julia object according to the MLJ convention, call scitype:","category":"page"},{"location":"#","page":"Home","title":"Home","text":"using MLJScientificTypes # hide\nscitype(3.14)","category":"page"},{"location":"#","page":"Home","title":"Home","text":"For a vector, you can use scitype or elscitype (which will give you a scitype corresponding to the elements):","category":"page"},{"location":"#","page":"Home","title":"Home","text":"scitype([1,2,3,missing])","category":"page"},{"location":"#","page":"Home","title":"Home","text":"elscitype([1,2,3,missing])","category":"page"},{"location":"#","page":"Home","title":"Home","text":"For an iterable, you can use scitype_union which gives you the tightest union of scitypes corresponding to the elements:","category":"page"},{"location":"#","page":"Home","title":"Home","text":"scitype_union((ifelse(isodd(i), i, missing) for i in 1:5))","category":"page"},{"location":"#","page":"Home","title":"Home","text":"note that scitype_union has to go over all elements which is slow whereas scitype and elscitype can often be immediately returned upon inspection of   the machine type.","category":"page"},{"location":"#Type-coercion-work-flow-for-tabular-data-1","page":"Home","title":"Type coercion work-flow for tabular data","text":"","category":"section"},{"location":"#","page":"Home","title":"Home","text":"The standard workflow involves the following two steps:","category":"page"},{"location":"#","page":"Home","title":"Home","text":"inspect the schema of the data and the scitypes in particular\nprovide pairs or a dictionary with column names and scitypes for any changes","category":"page"},{"location":"#","page":"Home","title":"Home","text":"you may want and coerce the data to those scitypes","category":"page"},{"location":"#","page":"Home","title":"Home","text":"using MLJScientificTypes # hide\nusing DataFrames, Tables\nX = DataFrame(\n     name=[\"Siri\", \"Robo\", \"Alexa\", \"Cortana\"],\n     height=[152, missing, 148, 163],\n     rating=[1, 5, 2, 1])\nschema(X)","category":"page"},{"location":"#","page":"Home","title":"Home","text":"inspecting the scitypes:","category":"page"},{"location":"#","page":"Home","title":"Home","text":"schema(X).scitypes","category":"page"},{"location":"#","page":"Home","title":"Home","text":"but in this case you may want to map the names to Multiclass, the height to Continuous and the ratings to OrderedFactor; to do so use the coerce function:","category":"page"},{"location":"#","page":"Home","title":"Home","text":"Xfixed = coerce(X, :name=>Multiclass,\n                   :height=>Continuous,\n                   :rating=>OrderedFactor)\nschema(Xfixed).scitypes","category":"page"},{"location":"#","page":"Home","title":"Home","text":"Note that, as it encountered missing values in height it coerced the type to Union{Missing,Continuous} and a warning is issued (to avoid such warnings, coerce to Union{Missing,T} where appropriate)","category":"page"},{"location":"#","page":"Home","title":"Home","text":"One can also make a replacement based on existing scientific type, instead of feature name:","category":"page"},{"location":"#","page":"Home","title":"Home","text":"X  = (x = [1, 2, 3],\n      y = rand(3),\n      z = [10, 20, 30])\nXfixed = coerce(X, Count=>Continuous)\nschema(Xfixed).scitypes","category":"page"},{"location":"#","page":"Home","title":"Home","text":"Finally there is a coerce! method that does in-place coercion provided the data structure allows it (at the moment only DataFrames.DataFrame is supported).","category":"page"},{"location":"#Notes-1","page":"Home","title":"Notes","text":"","category":"section"},{"location":"#","page":"Home","title":"Home","text":"We regard the built-in Julia type Missing as a scientific type. The new scientific types introduced in the current package are rooted in the abstract type Found (see tree above).\nFinite{N}, Multiclass{N} and OrderedFactor{N} are all parametrised by the number of levels N. We export the alias Binary = Finite{2}.\nImage{W,H}, GrayImage{W,H} and ColorImage{W,H} are all parametrised by the image width and height dimensions, (W, H).\nThe function scitype has the fallback value Unknown.","category":"page"},{"location":"#Special-note-on-binary-data-1","page":"Home","title":"Special note on binary data","text":"","category":"section"},{"location":"#","page":"Home","title":"Home","text":"MLJScientificTypes does not define a separate \"binary\" scientific type. Rather, when binary data has an intrinsic \"true\" class (for example pass/fail in a product test), then it should be assigned an OrderedFactor{2} scitype, while data with no such class (e.g., gender) should be assigned a Multiclass{2} scitype. In the former case we recommend that the \"true\" class come after \"false\" in the ordering (corresponding to the usual assignment \"false=0\" and \"true=1\"). Of course, Finite{2} covers both cases of binary data.","category":"page"},{"location":"#Detailed-usage-examples-1","page":"Home","title":"Detailed usage examples","text":"","category":"section"},{"location":"#","page":"Home","title":"Home","text":"using MLJScientificTypes # hide\nusing CategoricalArrays\nscitype((2.718, 42))","category":"page"},{"location":"#","page":"Home","title":"Home","text":"Let's try with categorical valued objects:","category":"page"},{"location":"#","page":"Home","title":"Home","text":"v = categorical(['a', 'c', 'a', missing, 'b'], ordered=true)\nscitype(v[1])","category":"page"},{"location":"#","page":"Home","title":"Home","text":"and","category":"page"},{"location":"#","page":"Home","title":"Home","text":"elscitype(v)","category":"page"},{"location":"#","page":"Home","title":"Home","text":"you could coerce this to Multiclass:","category":"page"},{"location":"#","page":"Home","title":"Home","text":"w = coerce(v, Union{Missing,Multiclass})\nelscitype(w)","category":"page"},{"location":"#Working-with-tables-1","page":"Home","title":"Working with tables","text":"","category":"section"},{"location":"#","page":"Home","title":"Home","text":"using MLJScientificTypes # hide\ndata = (x1=rand(10), x2=rand(10))\nscitype(data)","category":"page"},{"location":"#","page":"Home","title":"Home","text":"you can also use schema:","category":"page"},{"location":"#","page":"Home","title":"Home","text":"schema(data)","category":"page"},{"location":"#","page":"Home","title":"Home","text":"and use <: for type checks:","category":"page"},{"location":"#","page":"Home","title":"Home","text":"scitype(data) <: Table(Continuous)","category":"page"},{"location":"#","page":"Home","title":"Home","text":"scitype(data) <: Table(Infinite)","category":"page"},{"location":"#","page":"Home","title":"Home","text":"or specify multiple types directly:","category":"page"},{"location":"#","page":"Home","title":"Home","text":"data = (x=rand(10), y=collect(1:10), z = [1,2,3,1,2,3,1,2,3,1])\ndata = coerce(data, :z=>OrderedFactor)\nscitype(data) <: Table(Continuous,Count,OrderedFactor)","category":"page"},{"location":"#Tuples,-arrays-and-tables-1","page":"Home","title":"Tuples, arrays and tables","text":"","category":"section"},{"location":"#","page":"Home","title":"Home","text":"Important Definition 1 Under any convention, the scitype of a tuple is a Tuple type parametrised by scientific types:","category":"page"},{"location":"#","page":"Home","title":"Home","text":"using MLJScientificTypes #hide\nscitype((1, 4.5))","category":"page"},{"location":"#","page":"Home","title":"Home","text":"Important Definition 2 The scitype of an AbstractArray, A, is alwaysAbstractArray{U} where U is the union of the scitypes of the elements of A, with one exception: If typeof(A) <: AbstractArray{Union{Missing,T}} for some T different from Any, then the scitype of A is AbstractArray{Union{Missing, U}}, where U is the union over all non-missing elements, even if A has no missing elements.","category":"page"},{"location":"#","page":"Home","title":"Home","text":"This exception is made for performance reasons. If one wants to override it, one uses scitype(A, tight=true).","category":"page"},{"location":"#","page":"Home","title":"Home","text":"v = [1.3, 4.5, missing]\nscitype(v)","category":"page"},{"location":"#","page":"Home","title":"Home","text":"scitype(v[1:2])","category":"page"},{"location":"#","page":"Home","title":"Home","text":"scitype(v[1:2], tight=true)","category":"page"},{"location":"#","page":"Home","title":"Home","text":"Performance note: Computing type unions over large arrays is expensive and, depending on the convention's implementation and the array eltype, computing the scitype can be slow. In the MLJ convention this is mitigated with the help of the ScientificTypes.Scitype method, of which other conventions could make use. Do ?ScientificTypes.Scitype for details. An eltype Any may lead to poor performances and you may want to consider replacing an array A with broadcast(identity, A) to collapse the eltype and speed up the computation.","category":"page"},{"location":"#","page":"Home","title":"Home","text":"Any table implementing the Tables interface has a scitype encoding the scitypes of its columns:","category":"page"},{"location":"#","page":"Home","title":"Home","text":"using CategoricalArrays\nX = (x1=rand(10),\n     x2=rand(10),\n     x3=categorical(rand(\"abc\", 10)),\n     x4=categorical(rand(\"01\", 10)))\nschema(X)","category":"page"},{"location":"#","page":"Home","title":"Home","text":"Important Definition 3 Specifically, if X has columns c1, ..., cn, then","category":"page"},{"location":"#","page":"Home","title":"Home","text":"scitype(X) == Table{Union{scitype(c1), ..., scitype(cn)}}","category":"page"},{"location":"#","page":"Home","title":"Home","text":"With this definition, common type checks can be performed with tables. For instance, you could check that each column of X has an element scitype that is either Continuous or Finite:","category":"page"},{"location":"#","page":"Home","title":"Home","text":"scitype(X) <: Table{<:Union{AbstractVector{<:Continuous}, AbstractVector{<:Finite}}}","category":"page"},{"location":"#","page":"Home","title":"Home","text":"A built-in Table constructor provides a shorthand for the right-hand side:","category":"page"},{"location":"#","page":"Home","title":"Home","text":"scitype(X) <: Table(Continuous, Finite)","category":"page"},{"location":"#","page":"Home","title":"Home","text":"Note that Table(Continuous,Finite) is a type union and not a Table instance.","category":"page"},{"location":"#The-MLJ-convention-1","page":"Home","title":"The MLJ convention","text":"","category":"section"},{"location":"#","page":"Home","title":"Home","text":"The table below summarises the MLJ convention for representing scientific types:","category":"page"},{"location":"#","page":"Home","title":"Home","text":"Type T scitype(x) for x::T package required\nMissing Missing \nAbstractFloat Continuous \nInteger Count \nString Textual \nCategoricalValue Multiclass{N} where N = nlevels(x), provided x.pool.ordered == false CategoricalArrays\nCategoricalString Multiclass{N} where N = nlevels(x), provided x.pool.ordered == false CategoricalArrays\nCategoricalValue OrderedFactor{N} where N = nlevels(x), provided x.pool.ordered == true CategoricalArrays\nCategoricalString OrderedFactor{N} where N = nlevels(x) provided x.pool.ordered == true CategoricalArrays\nAbstractArray{<:Gray,2} GrayImage{W,H} where (W, H) = size(x) ColorTypes\nAbstractArrray{<:AbstractRGB,2} ColorImage{W,H} where (W, H) = size(x) ColorTypes\nany table type T supported by Tables.jl Table{K} where K=Union{column_scitypes...} Tables","category":"page"},{"location":"#","page":"Home","title":"Home","text":"Here nlevels(x) = length(levels(x.pool)).","category":"page"},{"location":"#Automatic-type-conversion-1","page":"Home","title":"Automatic type conversion","text":"","category":"section"},{"location":"#","page":"Home","title":"Home","text":"The autotype function allows to use specific rules in order to guess appropriate scientific types for tabular data. Such rules would typically be more constraining than the ones implied by the active convention. When autotype is used, a dictionary of suggested types is returned for each column in the data; if none of the specified rule applies, the ambient convention is used as \"fallback\".","category":"page"},{"location":"#","page":"Home","title":"Home","text":"The function is called as:","category":"page"},{"location":"#","page":"Home","title":"Home","text":"autotype(X)","category":"page"},{"location":"#","page":"Home","title":"Home","text":"If the keyword only_changes is passed set to true, then only the column names for which the suggested type is different from that provided by the convention are returned.","category":"page"},{"location":"#","page":"Home","title":"Home","text":"autotype(X; only_changes=true)","category":"page"},{"location":"#","page":"Home","title":"Home","text":"To specify which rules are to be applied, use the rules keyword  and specify a tuple of symbols referring to specific rules; the default rule is :few_to_finite which applies a heuristic for columns which have relatively few values, these columns are then encoded with an appropriate Finite type. It is important to note that the order in which the rules are specified matters; rules will be applied in that order.","category":"page"},{"location":"#","page":"Home","title":"Home","text":"autotype(X; rules=(:few_to_finite,))","category":"page"},{"location":"#","page":"Home","title":"Home","text":"Finally, you can also use the following shorthands:","category":"page"},{"location":"#","page":"Home","title":"Home","text":"autotype(X, :few_to_finite)\nautotype(X, (:few_to_finite, :discrete_to_continuous))","category":"page"},{"location":"#Available-rules-1","page":"Home","title":"Available rules","text":"","category":"section"},{"location":"#","page":"Home","title":"Home","text":"Rule symbol scitype suggestion\n:few_to_finite an appropriate Finite subtype for columns with few distinct values\n:discrete_to_continuous if not Finite, then Continuous for any Count or Integer scitypes/types\n:string_to_multiclass Multiclass for any string-like column","category":"page"},{"location":"#","page":"Home","title":"Home","text":"Autotype can be used in conjunction with coerce:","category":"page"},{"location":"#","page":"Home","title":"Home","text":"X_coerced = coerce(X, autotype(X))","category":"page"},{"location":"#Examples-1","page":"Home","title":"Examples","text":"","category":"section"},{"location":"#","page":"Home","title":"Home","text":"By default it only applies the :few_to_many rule","category":"page"},{"location":"#","page":"Home","title":"Home","text":"using MLJScientificTypes # hide\nn = 50\nX = (a = rand(\"abc\", n),         # 3 values, not number        --> Multiclass\n     b = rand([1,2,3,4], n),     # 4 values, number            --> OrderedFactor\n     c = rand([true,false], n),  # 2 values, number but only 2 --> Multiclass\n     d = randn(n),               # many values                 --> unchanged\n     e = rand(collect(1:n), n))  # many values                 --> unchanged\nautotype(X, only_changes=true)","category":"page"},{"location":"#","page":"Home","title":"Home","text":"For example, we could first apply the :discrete_to_continuous rule, followed by :few_to_finite rule. The first rule will apply to b and e but the subsequent application of the second rule will mean we will get the same result apart for e (which will be Continuous)","category":"page"},{"location":"#","page":"Home","title":"Home","text":"autotype(X, only_changes=true, rules=(:discrete_to_continuous, :few_to_finite))","category":"page"},{"location":"#","page":"Home","title":"Home","text":"One should check and possibly modify the returned dictionary before passing to coerce.","category":"page"}]
}
